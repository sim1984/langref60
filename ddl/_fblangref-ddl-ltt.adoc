[[fblangref_ddl_ltt]]
= LOCAL TEMPORARY TABLE

В отличие от глобальных временных таблиц (GTT), которые имеют постоянные метаданные, хранящиеся в системном каталоге, локальные временные таблицы (LTT) существуют только в рамках соединения, которое их создало. Определение таблицы является приватным для соединения которое создало эту таблицу. LTT автоматически удаляется при завершении соединения. Жизненный цикл данных зависит от предложения `ON COMMIT`: при `ON COMMIT DELETE ROWS` (по умолчанию) данные являются частными для каждой транзакции и удаляются при завершении транзакции; при `ON COMMIT PRESERVE ROWS` данные являются общими для всех транзакций в соединении и сохраняются до завершения соединения.

Локальные временные таблицы хранят свои данные и индексы во временных файлах, аналогично глобальным временным таблицам. Каждое соединение имеет собственное временное файловое пространство для данных LTT.

Когда соединение завершается (как в обычном режиме, так и из-за ошибки), все локальные временные таблицы, созданные этим соединением, автоматически удаляются вместе со своими данными. Явная очистка не требуется.

== Зачем нужны локальные временные таблицы?

Локальные временные таблицы полезны в сценариях, где требуется временное хранилище без влияния на метаданные базы данных:

=== Временное хранилище в базах данных только для чтения

Поскольку определения локальных временных таблиц не хранятся в базе данных, их можно создавать и использовать, даже если база данных находится в режиме только для чтения.

Глобальные временные таблицы (GTT), с другой стороны, не могут быть созданы в базах данных только для чтения, поскольку их создание требует изменения метаданных. Что касается использования (операции DML), в базе данных только для чтения разрешены только GTT с `ON COMMIT DELETE ROWS`.

=== Определение таблицы видимое только в текущей сессии

Каждое соединение может создавать свои собственные временные таблицы с одинаковыми именами без конфликтов. Определения таблиц полностью изолированы между соединениями.

=== Временное хранилище по запросу

LTTs предоставляют быстрый способ создания временного хранилища во время сеанса для промежуточных результатов, преобразований данных, или других временных задач обработки, не оставляя никаких следов в базе данных после отключения.

== Индексы для LTT

Для локальных временных таблиц можно создавать индексы. Эти индексы также являются временными объектами, метаданные которых хранятся только в памяти текущего соединения. Не все виды индексов могут быть созданы для LTT. В настоящий момент для LTT нельзя создать индексы по выражению и частичные индексы.

[source,sql]
----
create local temporary table temp_orders (
    order_id integer not null,
    customer_id integer,
    order_date date
);

create unique index idx_temp_orders_pk on temp_orders (order_id);
create descending index idx_temp_orders_date on temp_orders (order_date);
create index idx_temp_orders_cust on temp_orders (customer_id);
----

== Мониторинг

Поскольку локальные временные таблицы являются частными для соединения и не хранятся в системном каталоге, они не видны в `RDB$RELATIONS` или `RDB$RELATION_FIELDS`. Вместо этого предоставляются две новые таблицы мониторинга для проверки локальных временных таблиц в базе данных. См. <<fblangref-montables-local_tables>> и <<fblangref-montables-local_table_columns>>.

== Ограничения локальных временных таблиц

=== Ограничения на столбцы

* **DEFAULT значения**: Столбцы не могут иметь значений по умолчанию;
* **COMPUTED BY столбцы**: Вычисляемые столбцы не поддерживаются.
* **IDENTITY столбцы**: Столбцы идентификации (auto-increment) не поддерживаются.
* **ARRAY типы**: Столбцы типа массив не поддерживаются.
* **Изменения доменов**: Столбцы могут быть определены с использованием доменов, но изменения в определении домена не распространяются на существующие столбцы LTT. Столбец сохраняет характеристики домена такими, какими они были на момент его создания.

=== Ограничения целостности

* **PRIMARY KEY**: Первичные ключи не поддерживаются.
* **FOREIGN KEY**: Внешние ключи не поддерживаются.
* **CHECK ограничения**: Проверочные ограничения не поддерживаются.
* **NOT NULL ограничения**: Поддерживаются только не именованные ограничения `NOT NULL`.

=== Ограничения на индексы

* Индексы по выражению не поддерживаются.
* Частичные индексы не поддерживаются.

=== Другие ограничения

* **Предложение SQL SECURITY**: Предложение `SQL SECURITY` не применимо к LTT.
* **Максимальное количество LTTs**: Максимальное количество активных локальных временных таблиц составляет 1024 для каждого соединения.
* **Ссылка из хранимых объектов**: LLT-объекты нельзя напрямую использовать в хранимых процедурах, триггерах, представлениях или других постоянных объектах базы данных. Попытка сделать это приведет к ошибке. Однако доступ к LTT-объектам можно получить через `EXECUTE STATEMENT` внутри постоянных объектов, поскольку SQL-текст анализируется во время выполнения.

== Сравнение локальных и глобальных временных таблиц

[cols="<5,<4,<4", frame="all", options="header",stripes="none"]
|===
^| Возможность
^| GTT
^| LTT

|Хранение метаданных
|Системные таблицы (`RDB$RELATIONS` и другие)
|В памяти соединения

|Видимость определения
|Все соединения
|Только создавшее соединение

|Хранение определения
|Постоянное (до явного удаления)
|До завершения соединения

|Создание в read-only БД
|Нет
|Да

|Использование в read-only БД
|Только `ON COMMIT DELETE ROWS`
|`ON COMMIT DELETE ROWS` и ON COMMIT PRESERVE ROWS

|Поддержка схемы
|Да
|Да

|Индексы
|Полная поддержка
|Базовая поддержка (не поддерживаются частичные индексы и индексы по выражениям)

|DDL триггеры
|Срабатывают при CREATE/DROP/ALTER
|Не срабатывают

|Поддержка DML триггеров
|Да
|Не поддерживаются.

|`NOT NULL` на уровне поля
|Поддерживаются
|Поддерживаются

|Ограничения PK, FK, UNIQUE, CHECK
|Поддерживаются
|Не поддерживаются.

|Именованные ограничение
|Поддерживаются
|Не поддерживаются.

|Явные привилегии
|Поддерживаются
|Не поддерживаются.

|===

[[fblangref-ddl-ltt-create]]
== `CREATE LOCAL TEMPORARY TABLE`

.Назначение
Создание новой локальной временной таблицы.
(((CREATE LOCAL TEMPORARY)))

.Доступно в
DSQL, ESQL

[[fblangref-ddl-tbl-create-ltt-syntax]]
.Синтаксис
[listing,subs="+quotes,macros,attributes"]
----
CREATE LOCAL TEMPORARY TABLE [IF NOT EXISTS] [ _tbl-schema_ <period> ] _tablename_
  (<col_def> [, <col_def> ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]

<col_def> ::=
  _colname_ { <datatype> | [ _dom-schema_ <period> ] _domain_name_ }
  [NOT NULL]
  [COLLATE [ _coll-schema_ <period> ] _collation_name_]


<datatype> ::=
    <scalar_datatype> | <blob_datatype>

<scalar_datatype> ::=  См. <<fblangref-datatypes-syntax-scalar,Синтаксис скалярных типов данных>>

<blob_datatype> ::= См. <<fblangref-datatypes-syntax-blob,Синтаксис типа данных BLOB>>

----

[[fblangref-ddl-tbl-create-ltt]]
.Параметры оператора `CREATE LOCAL TEMPORARY TABLE`
[cols="<1,<3", options="header",stripes="none"]
|===
^|Параметр
^|Описание

|tbl-schema
|Имя схемы таблицы. Если не указано, то таблица создаётся в текущей схеме.

|tablename
|Имя таблицы, может содержать до 63 символов.

|datatype
|Тип данных SQL.

|dom-schema
|Имя схемы домена. Если не указано, то домен будет найден в пути поиска.

|domain_name
|Имя домена.

|coll-schema
|Имя схемы сортировки (сравнения). Если не указано, то сортировка будет найдена в пути поиска.

|collation_name
|Имя сортировки (сравнения). Необходимо указывать, если вы хотите, чтобы порядок сортировки для столбца отличался от порядка сортировки по умолчанию для этого столбца. Порядок сортировки по умолчанию для столбца – это порядок сортировки по умолчанию для набора символов.

|===

Оператор `CREATE LOCAL TEMPORARY TABLE` создаёт новую локальную временную таблицу. Если перед именем таблицы указана схема, то таблица будет создана в указанной схеме, в противном случае таблица будет создана в текущей схеме (первая валидная схема в пути поиска). Имя локальной таблицы должно быть уникальным среди имён всех таблиц, представлений (VIEWs) и хранимых процедур внутри заданной (текущей) схемы.

[IMPORTANT]
====
Поскольку `CREATE LOCAL TEMPORARY TABLE` является DDL оператором, то после того как создаваемая таблица привязана к схеме во время подготовки оператора, путь поиска неявно и временно изменяется. Эта корректировка устанавливает путь поиска на схему таблицы. Кроме того, схема `SYSTEM` добавляется как последняя схема в путь поиска. Это обозначает, что имена объектов метаданных, используемые внутри оператора `CREATE TABLE`, такие как домены, будут разрешаться относительно этого нового пути поиска.
====

Если используется предложение `IF NOT EXISTS`, то оператор `CREATE LOCAL TEMPORARY TABLE` попытается создать новую локальную временную таблицу без выдачи ошибки, если таблица (любого типа) с таким именем уже существует.

[NOTE]
====
Таблицы используют одно и то же "`пространство имён`" относительно схемы, что и представления и хранимые процедуры. Таким образом, если хранимая процедура с именем `SOME_NAME` существует в заданной схеме и будет попытка выполнить `CREATE LOCAL TEMPORARY TABLE IF NOT EXISTS SOME_NAME`, то таблица не будет создана без выдачи ошибки.
====

Локальная временная таблица должна содержать, по меньшей мере, один столбец. Имя столбца должно быть уникальным для создаваемой таблицы. Для столбца обязательно должен быть указан либо тип данных, либо имя домена, характеристики которого будут скопированы для столбца. В качестве типа столбца можно использовать любой тип данных SQL, кроме массивов.

[[_fblangref_ddl_ltt_create_column_nullable]]
=== Ограничение `NOT NULL`

(((CREATE LOCAL TEMPORARY TABLE, NOT NULL)))
По умолчанию столбец может принимать значение `NULL`.

Необязательное предложение `NOT NULL` указывает, что столбцу не может быть присвоено значение `NULL`.

[[_fblangref_ddl_ltt_create_column_default]]
=== Значение по умолчанию

Локальные временные таблицы не поддерживают указание для столбцов значения по умолчанию.

[[_fblangref_ddl_ltt_create_column_domain]]
=== Столбцы основанные на домене

Для определения столбца, можно воспользоваться ранее описанным доменом. Если определение столбца основано на домене, оно может включать предложение `COLLATE`, которое перекрывают значения указанные при определении домена. Определение такого столбца может включать ограничение `NOT NULL`, если домен его ещё не содержит.

[IMPORTANT]
====
Следует обратить внимание на то, что ссылка на домен не "сохраняется" в метаданных столбца локальной временной таблицы. В момент добавления нового столбца с использованием домена, из этого домена копируются все необходимые характеристики, после чего столбец LTT никак не связан с доменом.

Здесь слово "сохраняется" взято в кавычки, поскольку для LTT метаданные вообще не хранятся в базе данных, они существуют только в памяти соединения создавшего LTT.
====

[[fblangref-ddl-ltt-create-column-identity]]
=== Столбцы идентификации (автоинкремент)

Локальные временные таблицы не поддерживают столбцы идентификации.

[[fblangref-ddl-ltt-create-column-computed]]
=== Вычисляемые поля

Локальные временные таблицы не поддерживают вычисляемые поля.

[[fblangref-ddl-ltt-create-column-array]]
=== Столбцы типа массив

Локальные временные таблицы не поддерживают столбцы с типом массив.

[[fblangref-ddl-ltt-create-data-live]]
=== Жизненный цикл данных

==== ON COMMIT DELETE ROWS

При создании локальной временной таблицы с параметром `ON COMMIT DELETE ROWS` (по умолчанию) данные являются приватными для каждой транзакции и автоматически удаляются по завершении транзакции (COMMIT или ROLLBACK). Поскольку Firebird поддерживает несколько одновременных транзакций в рамках одного соединения, каждая транзакция имеет собственное изолированное представление данных.

[source,sql]
----
create local temporary table temp_work (id integer);

insert into temp_work values (1);
insert into temp_work values (2);
select count(*) from temp_work;  -- Returns 2

commit;

select count(*) from temp_work;  -- Returns 0 (data was deleted)
----

==== ON COMMIT PRESERVE ROWS

При создании LTT с параметром `ON COMMIT PRESERVE ROWS` данные сохраняются между транзакциями и остаются доступными до тех пор, пока не будет разорвано соединение.

[source,sql]
----
create local temporary table session_data (id integer)
on commit preserve rows;

insert into session_data values (1);
commit;

insert into session_data values (2);
commit;

select count(*) from session_data;  -- Returns 2 (data preserved across commits)
----

==== Поведение при COMMIT/ROLLBACK RETAINING

Аналогичное поведению GTT, команды `COMMIT RETAINING` и `ROLLBACK RETAINING` сохраняют данные в локальных временных таблицах с опцией `ON COMMIT DELETE ROWS`.

[[fblangref-ddl-ltt-create-who]]
=== Кто может создать локальную временную таблицу?

Создать локальную временную таблицу может любой пользователь, который подключился к базе данных.

[[fblangref-ddl-ltt-create-examples]]
=== Примеры

.Создайте простой LTT с настройками по умолчанию (ON COMMIT DELETE ROWS).
[example]
====
[source,sql]
----
create local temporary table temp_results (
    id integer not null,
    val varchar(100)
);
----
====

.Создание LTT, которая сохраняет данные между транзакциями.
[example]
====
[source,sql]
----
create local temporary table session_cache (
    key varchar(50) not null,
    data blob
) on commit preserve rows;
----
====

.Создание LTT в определенной схеме.
[example]
====
[source,sql]
----
create local temporary table my_schema.work_table (
    x integer,
    y integer
);
----
====


[[fblangref-ddl-ltt-alter]]
== `ALTER TABLE` (LTT)

.Назначение
Изменение структуры таблицы.
(((LOCAL TEMPORARY TABLE, ALTER TABLE)))

.Доступно в
DSQL, ESQL.

Локальные временные таблицы (LTT) могут быть изменены тем же оператором, что и обычные таблицы, то есть `ALTER TABLE`. Поскольку возможности локальных временных таблиц ограничены, то не все возможности исходного оператора `ALTER TABLE` доступны для LTT. Здесь приведён синтаксис с усечёнными возможностями для локальных временных таблиц.

.Синтаксис
[listing,subs="+quotes,attributes,macros"]
----
ALTER TABLE [ _tbl-schema_ <period> ] _tablename_
  <operation> [, <operation>];

<operation> ::=
    ADD [COLUMN] [IF NOT EXISTS] <col_def>
  | DROP [COLUMN] [IF EXISTS] _colname_
  | ALTER [COLUMN] colname <col_mod>

<col_def> ::=
    <regular_col_def>

<regular_col_def> ::=
  colname { <datatype> | [ _dom-schema_ <period> ] _domainname_ }
  [NOT NULL]
  [COLLATE [ _coll-schema_ <period> ] _collation_name_]

<col_mod> ::=
     TO _newname_
  |  POSITION _newpos_
  | <regular_col_mod>

<regular_col_mod> ::=
  |  TYPE { <datatype>  | [ _dom-schema_ <period> ] _domain_name_ }
  |  SET NOT NULL
  |  DROP NOT NULL

<datatype> ::=
    <scalar_datatype> | <blob_datatype>

<scalar_datatype> ::=  См. <<fblangref-datatypes-syntax-scalar,Синтаксис скалярных типов данных>>

<blob_datatype> ::= См. <<fblangref-datatypes-syntax-blob,Синтаксис типа данных BLOB>>
----

[[fblangref-ddl-ltt-altertbl]]
.Параметры оператора `ALTER TABLE`
[cols="<1,<3", options="header",stripes="none"]
|===
^|Параметр
^|Описание

|tbl-schema
|Имя схемы таблицы. Если не указано, то таблица будет найдена в пути поиска.

|tablename
|Имя таблицы.

|operation
|Одна из допустимых операций по изменению структуры таблицы.

|colname
|Имя столбца таблицы, может содержать до 63 символов.
Должно быть уникальным внутри таблицы.

|newname
|Новое имя столбца таблицы, может содержать до 63 символов.
Должно быть уникальным внутри таблицы.

|newpos
|Новая позиция столбца в таблице. Целое число в диапазоне от 1 до количества столбцов таблицы.

|datatype
|Тип данных SQL.

|dom-schema
|Имя схемы домена. Если не указано, то домен будет найден в пути поиска.

|domain_name
|Имя домена.

|coll-schema
|Имя схемы сортировки (сравнения). Если не указано, то сортировка будет найдена в пути поиска.

|collation_name
|Имя сортировки (сравнения). Необходимо указывать, если вы хотите, чтобы порядок сортировки для столбца отличался от порядка сортировки по умолчанию для этого столбца. Порядок сортировки по умолчанию для столбца – это порядок сортировки по умолчанию для набора символов.

|===

Оператор `ALTER TABLE` изменяет структуру существующей таблицы. Для локальной временной таблицы можно изменить только состав её столбцов или характеристики заданного столбца. Добавить ограничения таблицы, ограничения столбцов и значения по умолчанию для столбцов невозможно.

Если указано только имя таблицы, то её поиск производится в путях поиска (`SEARCH_PATH`). Будет изменена первая найденная таблица с заданным именем среди схем перечисленных в путях поиска.

[IMPORTANT]
====
Поскольку `ALTER TABLE` является DDL оператором, то после того как модифицируемая таблица привязана к схеме во время подготовки оператора, путь поиска неявно и временно изменяется. Эта корректировка устанавливает путь поиска на схему таблицы. Кроме того, схема `SYSTEM` добавляется как последняя схема в путь поиска. Это обозначает, что имена объектов метаданных, используемые внутри оператора `ALTER TABLE`, такие как домены, будут разрешаться относительно этого нового пути поиска.
====

Одиночный оператор `ALTER TABLE` позволяет производить множество операций добавления/удаления столбцов и ограничений, а также модификаций столбцов. Список операций выполняемых при модификации таблицы разделяется запятой.

[[fblangref-ddl-ltt-alter-who]]
=== Кто может изменить таблицу?

Выполнить оператор `ALTER TABLE` для локальной временной таблицы может тот, кто её создал в текущем соединении.

=== Примеры

[source,sql]
----
create local temporary table temp_data (id integer);

alter table temp_data add name varchar(50) not null;
alter table temp_data alter column name position 1;
alter table temp_data alter column name to full_name;
alter table temp_data alter column id type bigint;
----

.См. также:
<<fblangref-ddl-ltt-create>>, <<fblangref-ddl-ltt-recreate>>.

[[fblangref-ddl-ltt-drop]]
== `DROP TABLE` (LTT)

.Назначение
Удаление существующей таблицы.
(((LOCAL TEMPORARY TABLE, DROP TABLE)))

.Доступно в
DSQL, ESQL.

.Синтаксис
[listing,subs="+quotes"]
----
DROP TABLE [IF EXISTS] [ _tbl-schema_ <period> ] _tablename_
----

.Параметры оператора `DROP TABLE`
[cols="<1,<3", options="header",stripes="none"]
|===
^|Параметр
^|Описание

|tbl-schema
|Имя схемы таблицы. Если не указано, то таблица будет найдена в пути поиска.

|tablename
|Имя таблицы.

|===

Локальные временные таблицы (LTT) могут быть удалены тем же оператором, что и обычные таблицы, то есть `DROP TABLE`.

Если указано только имя таблицы, то её поиск производится в путях поиска (`SEARCH_PATH`). Будет удалена первая найденная таблица с заданным именем среди схем перечисленных в путях поиска.

Если используется предложение `IF EXISTS`, то оператор `DROP TABLE` попытается удалить таблицу без выдачи ошибки, если её не существует. DDL триггеры не будут запускаться, если таблицы не существует.

[[fblangref-ddl-ltt-drop-who]]
=== Кто может удалить таблицу?

Выполнить оператор `DROP TABLE` для локальной временной таблицы может тот, кто её создал в текущем соединении.

=== Примеры

[source,sql]
----
DROP TABLE temp_data;

DROP TABLE IF EXISTS temp_data;
----

[[fblangref-ddl-ltt-recreate]]
== `RECREATE LOCAL TEMPORARY TABLE`

.Назначение
Создание новой локальной временной таблицы или пересоздание существующей.
(((CREATE LOCAL TEMPORARY)))

.Доступно в
DSQL, ESQL

[[fblangref-ddl-tbl-recreate-ltt-syntax]]
.Синтаксис
[listing,subs="+quotes,macros,attributes"]
----
RECREATE LOCAL TEMPORARY TABLE [IF NOT EXISTS] [ _tbl-schema_ <period> ] _tablename_
  (<col_def> [, <col_def> ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]

<col_def> ::=
  _colname_ { <datatype> | [ _dom-schema_ <period> ] _domain_name_ }
  [NOT NULL]
  [COLLATE [ _coll-schema_ <period> ] _collation_name_]


<datatype> ::=
    <scalar_datatype> | <blob_datatype>

<scalar_datatype> ::=  См. <<fblangref-datatypes-syntax-scalar,Синтаксис скалярных типов данных>>

<blob_datatype> ::= См. <<fblangref-datatypes-syntax-blob,Синтаксис типа данных BLOB>>

----

Полное описание определений столбцов и ограничений таблицы смотрите в разделе <<fblangref-ddl-ltt-create>>.

Оператор `RECREATE LOCAL TEMPORARY TABLE` Создаёт или пересоздаёт локальную временную таблицу. Если таблица с таким именем уже существует, то оператор `RECREATE LOCAL TEMPORARY TABLE` попытается удалить её и создать новую.

LTT создаётся или пересоздаётся в указанной схеме. Если указано только имя таблицы, то её поиск производится только в текущей схеме (первая валидная схема в путях поиска). Имя таблицы должно быть уникальным среди имён всех таблиц, представлений (VIEWs) и хранимых процедур внутри заданной (текущей) схемы.

[[fblangref-ddl-ltt-recreate-examples]]
=== Примеры

.Создание или пересоздание LTT в одной из схем в пути поиска
[example]
====
[source,sql]
----
recreate local temporary table temp_results (
    id integer not null,
    val varchar(100)
);
----
====

.См. также:
<<fblangref-ddl-ltt-create>>, <<fblangref-ddl-ltt-drop>>.
